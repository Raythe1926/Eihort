/* Copyright (c) 2012, Jason Lloyd-Price
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

#ifndef GEOMSOLID_H
#define GEOMSOLID_H

#include <cmath>
#include <cstdlib>
#include <vector>
#include "jmath.h"
#include "geombase.h"

struct triangulateio;

namespace eihort {
namespace geom {

class SolidBlockGeometry : public BlockGeometry {
	// A simple, normal block.
	// Most blocks that make up the world use this.

public:
	// Construct a SolidBlockGeometry with a single texture covering all 6 faces
	explicit SolidBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	// Construct a SolidBlockGeometry with the given textures on the 6 faces
	explicit SolidBlockGeometry( unsigned *tx, unsigned color = 0xffffffu );
	virtual ~SolidBlockGeometry();

	virtual void render( void *&meta, RenderContext *ctx );
	virtual GeometryCluster *newCluster();

	virtual bool beginEmit( GeometryCluster *out, InstanceContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );

	// Helper to set the color that is multiplied into the entire material
	inline void setColor( unsigned col ) { color = col; }
	// Helper to set the texture scale applied to the geometry's texture
	inline void setTexScale( float x, float y ) { xTexScale = x; yTexScale = y; }

protected:
	struct REALVec {
		// Internal intermediate representation of the contour

		// Position
		double v[2];

		// Helper to scale the length of the vector to a given length,
		// assuming it's already axis aligned
		void scaleToLenAA( double len ) {
			if( std::fabs(v[0]) < 0.01 ) {
				v[1] = v[1] > 0.0 ? len : -len;
			} else {
				v[0] = v[0] > 0.0 ? len : -len;
			}
		}

		void add( const REALVec &other ) {
			v[0] += other.v[0];
			v[1] += other.v[1];
		}

		void sub( const REALVec &other ) {
			v[0] -= other.v[0];
			v[1] -= other.v[1];
		}
	};

	// Helper to construct and emit the geometry describing an entire island
	static void emitContour( GeometryStream *out, const IslandDesc *ctx, int offsetPx );
	// Converts a sequence of contour points into unique loops which make up the island ('segments')
	// Also handles the case where a contour touches itself at a corner, producing extra holes
	// for Triangle, and extra segments to process
	static unsigned serializeContourPoints( const IslandDesc *ctx, unsigned nContourPoints, const Point *points, REALVec *outVec, int *segments, int baseSegIdx, std::vector<REALVec> &extraHoles );
	// Converts an IslandDesc to the structure expected by the Triangle library
	static void islandToTriangleIO( const IslandDesc *ctx, triangulateio *out );
	// Frees memory allocated by islandToTriangleIO
	static void freeIslandTriangleIO( triangulateio *out );
	// Dumps the geometry in tri into the given geometry stream
	static void emitTriangulated( GeometryStream *out, const IslandDesc *ctx, triangulateio *tri, int offsetPx );
	// Helper to emit a single quad, with a given Z offset in pixels (1/16ths of blocks)
	static void emitQuad( GeometryStream *out, const IslandDesc *ctx, int offsetPx );
	// Helper to emit a single quad, with offsets/shrinkage in all dimensions
	static void emitQuad( GeometryStream *out, const IslandDesc *ctx, int *offsets );

	// Actual render function, after the material state has been set
	void solidBlockRender( void *&meta, RenderContext *ctx );
	// Helper to apply the color to the global GL render state
	void applyColor();

	struct Vertex {
		// Vertex format used by geometry generated by SolidBlockGeometry
		
		// Position of the vertex, as a pixel (1/16th of a block size)
		// offset from the center of the qtree chunk
		short pos[3];
	};

	// Textures to use for each face
	unsigned tex[6];
	// Color to apply when rendering this geometry
	unsigned color;
	// Scaling factor applied at a global scale to UVs for this geometry
	float xTexScale, yTexScale;
};

class FoliageBlockGeometry : public SolidBlockGeometry {
	// SolidBlockGeometry that uses the biome shader
	// For leaves and grass and stuff

public:
	FoliageBlockGeometry( unsigned tx, unsigned foliageTex );
	FoliageBlockGeometry( unsigned *tx, unsigned foliageTex );
	~FoliageBlockGeometry();

	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void render( void *&meta, RenderContext *ctx );

protected:
	// The biome texture to use
	unsigned foliageTex;
};

class FoliageAlphaBlockGeometry : public FoliageBlockGeometry {
	// FoliageBlockGeometry which, rather than modulating the entire
	// texture by the biome color, adds the biome color to the texture, weighted
	// by the alpha channel.
	// Made mainly for the sides of grass blocks

public:
	FoliageAlphaBlockGeometry( unsigned tx, unsigned foliageTex );
	FoliageAlphaBlockGeometry( unsigned *tx, unsigned foliageTex );
	~FoliageAlphaBlockGeometry();

	virtual void render( void *&meta, RenderContext *ctx );
};

class TransparentSolidBlockGeometry : public SolidBlockGeometry {
	// SolidBlockGeometry which should be drawn with blending on
	// Mainly for water (glass is not drawn with blending)

public:
	explicit TransparentSolidBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	explicit TransparentSolidBlockGeometry( unsigned *tx, unsigned color = 0xffffffu );
	virtual ~TransparentSolidBlockGeometry();

	virtual void render( void *&meta, RenderContext *ctx );
};

class PortalBlockGeometry : public TransparentSolidBlockGeometry {
	// TransparentSolidBlockGeometry for portals

public:
	PortalBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	~PortalBlockGeometry();

	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );
};

class HashShapedBlockGeometry : public SolidBlockGeometry {
	// SolidBlockGeometry with the faces offset inward slightly

public:
	HashShapedBlockGeometry( unsigned tx, int *offsets = NULL );
	HashShapedBlockGeometry( unsigned *tx, int *offsets = NULL );
	~HashShapedBlockGeometry();

	virtual GeometryCluster *newCluster();

	virtual void render( void *&meta, RenderContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );

protected:
	// Number of pixels to offset each face
	int offsets[6];
};

class BiomeHashShapedBlockGeometry : public HashShapedBlockGeometry {
	// HashShapedBlockGeometry which uses the biome shader

public:
	BiomeHashShapedBlockGeometry( unsigned tx, int channel, int *offsets = NULL );
	BiomeHashShapedBlockGeometry( unsigned *tx, int channel, int *offsets = NULL );
	~BiomeHashShapedBlockGeometry();

	virtual void render( void *&meta, RenderContext *ctx );

protected:
	// The biome texture to use
	int biomeChannel;
};

class FullBrightBlockGeometry : public SolidBlockGeometry {
	// SolidBlockGeometry which ignores block lighting
	// Mostly useful for Lava

public:
	FullBrightBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	FullBrightBlockGeometry( unsigned *tx, unsigned color = 0xffffffu );
	~FullBrightBlockGeometry();

	virtual void render( void *&meta, RenderContext *ctx );
};

class SquashedSolidBlockGeometry : public SolidBlockGeometry {
	// Blocks that span the complete x/y direction, but only part of z
	// The texture is shifted vertically by half a block
	// Mainly for slabs

public:
	SquashedSolidBlockGeometry( int top, int bottom, unsigned tx, unsigned color = 0xffffffu );
	SquashedSolidBlockGeometry( int top, int bottom, unsigned *tx, unsigned color = 0xffffffu );
	~SquashedSolidBlockGeometry();

	virtual GeometryCluster *newCluster();
	virtual bool beginEmit( GeometryCluster *out, InstanceContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );

protected:
	// Offsets in pixels from the top and bottom of the block
	int top, bottom;
};

class CompactedSolidBlockGeometry : public SolidBlockGeometry {
	// Blocks that are 'squashed' in at least 2 dimensions

public:
	CompactedSolidBlockGeometry( int *offsets, unsigned tx, unsigned color = 0xffffffu );
	CompactedSolidBlockGeometry( int *offsets, unsigned *tx, unsigned color = 0xffffffu );
	~CompactedSolidBlockGeometry();

	virtual GeometryCluster *newCluster();
	virtual bool beginEmit( GeometryCluster *out, InstanceContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );

protected:
	// Offsets for each face, in pixels
	int offsets[6];
	// Which dimensions is it possible to create islands with?
	bool islandViable[3];
	// Are the islands 'full', or ISLAND_LOCK_?'d?
	bool fullIslands[3];
};

class MultiCompactedBlockGeometry : public SolidBlockGeometry {
	// SolidBlockGeometry which is composed of several smaller blocks within it

public:
	MultiCompactedBlockGeometry( int **offsets, unsigned nEmits, unsigned tx, unsigned color = 0xffffffu );
	MultiCompactedBlockGeometry( int **offsets, unsigned nEmits, unsigned *tx, unsigned color = 0xffffffu );
	~MultiCompactedBlockGeometry();

	virtual bool beginEmit( GeometryCluster *out, InstanceContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );
	
	// Toggle to show/hide specific faces on a per-subblock basis
	inline void showFace( unsigned emit, unsigned face, bool show ) const { offsets[emit].hide[face] = !show; }
	
protected:
	// Initializes the set of blocks emitted
	void setupOffsets( int **offsets, unsigned nEmits );
	
	// Number of sub-blocks to emit
	unsigned offsetCount;

	struct OffsetSet {
		// Description of the size of a sub-block

		// Hide this face?
		bool hide[6];
		// Offsets for each face
		int offsets[6];
	};
	// List of sub-blocks, one for each offsetCount
	OffsetSet *offsets;
};

class CompactedIslandBlockGeometry : public SolidBlockGeometry {
	// Compacted islands in multiple dimensions
	// Effectively a MultiCompactedBlockGeometry that generates islands
	// rather than single blocks
	// Designed primarily with fences in mind

public:
	CompactedIslandBlockGeometry( int **offsets, unsigned *nEmits, unsigned tx, unsigned color = 0xffffffu );
	CompactedIslandBlockGeometry( int **offsets, unsigned *nEmits, unsigned *tx, unsigned color = 0xffffffu );
	~CompactedIslandBlockGeometry();

	virtual bool beginEmit( GeometryCluster *out, InstanceContext *ctx );
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );
	
	inline void showFace( unsigned emit, unsigned face, bool show ) const { offsets[emit].hide[face] = !show; }
	
protected:
	// Initializes the set of blocks emitted
	void setupOffsets( int **offsets, unsigned *nEmits );
	
	// Starting index of the offsets in each dimension
	// The offsets for dimension i go from offsetStart[i] to offsetStart[i+1]-1
	unsigned offsetStart[4];

	struct OffsetSet {
		// Offsets to adjust the size of islands by

		// Hide this face?
		bool hide[6];
		// Does this sub-block disappear if there is only one block in this dimension?
		bool collapses;
		// Offsets for each face
		int offsets[6];
	};
	OffsetSet *offsets;
};

class DoorBlockGeometry : public SolidBlockGeometry {
	// Geometry generator for doors

public:
	explicit DoorBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	virtual ~DoorBlockGeometry();
	
	virtual GeometryCluster *newCluster();
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );
	
protected:
	// Access to a version of this geometry with the texture flipped
	// Do not attempt to access geom.texFlippedGeom()->texFlippedGeom()
	inline DoorBlockGeometry *texFlippedGeom() { return static_cast<DoorBlockGeometry*>(&texFlipped); }

	// Texture-flipped version of this SolidBlockGeometry
	SolidBlockGeometry texFlipped;
};

class StairsBlockGeometry : public SolidBlockGeometry {
	// Geometry generator for stairs

public:
	explicit StairsBlockGeometry( unsigned tx, unsigned color = 0xffffffu );
	explicit StairsBlockGeometry( unsigned *tx, unsigned color = 0xffffffu );
	virtual ~StairsBlockGeometry();
	
	virtual IslandMode beginIsland( IslandDesc *ctx );
	virtual void emitIsland( GeometryCluster *out, const IslandDesc *ctx );

protected:
	static bool continueIsland( IslandDesc *island, const InstanceContext *nextBlock );
};


} // namespace geom
} // namespace eihort

#endif
